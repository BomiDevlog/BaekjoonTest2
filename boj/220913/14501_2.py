n = int(input())
time = [0]*(n+1)
profit = [0]*(n+1)
dp = [0]*(n+2)

for i in range(1,n+1):
    time[i], profit[i] = map(int, input().split())

maxValue = 0
# dp[i] = i일부터 마지막 날까지 낼 수 있는 최대 이익
for i in range(n, 0, -1):
    if i+time[i] <= n+1: # 상담기간 안에 끝나는 경우
        dp[i] = max(profit[i]+dp[i+time[i]], maxValue)
        maxValue = dp[i] # 뒤에서부터 현재까지의 최대 이익
    else: # 상담기간을 벗어나는 경우
        dp[i] = maxValue # i번째 상담은 패스

print(dp[1])
'''
뒤쪽 날짜부터 거꾸로 확인하는 방식

1일차에 상담을 진행한다고 해보면

최대이익 = 1일차 상담금액 + 4일부터 마지막날까지의 최대 이익 = profit[1] + dp[4]이다.

이렇게 뒤쪽에서부터 매 상담에 대한 최대이익을 계산한다.

​

dp[i] = i일부터 마지막날까지의 최대 이익

dp[i] = max(profit[i]+dp[i+time[i]], maxValue)

maxValue는 뒤에서부터 현재까지의 최대 상담금액이다.
[출처] [백준] 14501번 퇴사|작성자 chex



'''
'''
https://animoto1.tistory.com/entry/%EB%B0%B1%EC%A4%80-dpdynamic-programming-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EB%AC%B8%EC%A0%9C-%EC%9C%A0%ED%98%95-%EC%84%A4%EB%AA%85-%EB%B0%8F-%ED%95%B4%EA%B2%B0%EB%B2%95-%ED%8C%8C%EC%9D%B4%EC%8D%AC


dp란?
  dp, dynamic programming의 줄임말이다. dp는 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법이다. 또한 큰 문제를 작은 문제로 나눠서 푸는 알고리즘이라고 흔히 말한다.

  dp의 핵심은 앞서 말한 수행 시간 효율성의 비약적 향상인데 이는 '메모이제이션'이라는 기법을 이용해 이미 계산된 결과(작은 문제)를 별도의 메모리에 저장해 다시 계산하지 않고 필요한 경우 사용하는 방식이다. 이 기법을 사용하면 시간복잡도가 훨씬 줄어들기에 수행 시간 효율성이 비약적으로 향상한다.

dp 문제유형
  dp문제의 조건은 두가지이다.

1. 최적 부분 구조 

  큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.

2. 중복되는 부분 문제

  동일하게 반복되는 작은 문제로 해결해야한다.

 dp문제의 해결은 대부분 dp식, 즉 점화식을 잘 세우는 것이 중요하다-!-! 

1. 주어진 문제가 dp문제 유형이 맞는지 확인하고, 최종적으로 구할 큰 문제가 뭔지 확인한다.

2. 작은 문제들과 큰 문제 사이의 관계를 점화식의 형태로 나타내 보자. 

3. top-down 방식 혹은 bottom-up 방식을 통해 문제를 풀어나가자.

 +) 탑다운 방식(하향식)은 메모이제이션을 통한 재귀함수를 이용한 방식이고 보톰업방식(상향식)은 결과 저장용 리스트인 dp테이블을 통해 반복문으로 문제를 해결하는 방식이다.

'''
