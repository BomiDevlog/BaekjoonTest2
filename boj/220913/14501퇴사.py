
'''
하루에 한 상담만 가능

최대 수익을 구하는 프로그램 작성


첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.

둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)

'''
n = int(input()) #남은기간 입력
dp = [0] * (n+1) # n+1일에 퇴사 #해당일자에 일하면 얻을수있는 최대값
t = [] #일자 리스트
p = [] #금액 리스트

for _ in range(n) :
    a,b = map(int, input().split()) #map() : 여러 요소에 하나의 함수를 한꺼번에 대응 # 변수 = map(함수명, 대응할 일련의 요소)

    t.append(a)
    p.append(b)
    #소요기간, 일당 입력

for i in range(n-1, -1, -1) : # n=7이라면 6~-1까지 -1씩 앞으로 감. 총 8개. # 뒤에서부터 계산을 해야 한다!
    # print('i: ',i)
    # print('dp[i+1]: ', dp[i+1])
    # print('i+t[i]: ',i+t[i] )
    # print('dp[i+t[i]]: ',dp[i+ t[i]] )
    # print('-----------')

    if i + t[i] > n :   # 상담기간 N일을 넘기는 경우
        dp[i] = dp[i+1]
    else : # 상담기간 안에 끝나는 경우
        dp[i] = max(dp[i+1], p[i] + dp[i+t[i]]) # max() 둘중에 큰 쪽을 변수에 대입.
#해당일자에 일할경우와 일하지않을경우를 비교
       
print(dp[0])
 #dp[n]부터 max로 계속 비교하면서 왔기 때문에 dp[0]에는 최대값이 들어있음 
'''
# range([start,] stop [, step])
# 초기값(디폴트는 0), 끝숫자는 n-1 , 증가값
# 개수는 stop-start/step
'''

'''

현재 일을 건너뛴(i+1) 이익과, 현재일 이익 + 현재 일을 하는데 걸리는 시간 후의 이익중에 더 큰 값으로 갱신

- dp[i+1]

- p[i] (현재 일자의 이익) + dp[i+t[i]] (현재 일을 하는데 걸리는 시간 후의 이익)


즉 점화식은 dp[i] = max(dp[i+1], p[i] + dp[i+t[i]] 이다

여기서 주의할 점은, 6일과 7일처럼 N일을 넘기는 경우이다. 이럴 땐 최댓값(dp[i+1])을 넣어준다 

[출처] (파이썬) 백준 14501번 퇴사|작성자 밍
'''
'''
DP : 동적 계획법( dynamic programming )


관계식 세우는 팁

​

1) 예시 한두개를 정확히 만들어서 거기서 일반화를 시작하는 것도 좋은 방법임.

​

2)예시 만들면서 뭔가 나올랑 말랑 하면 예시를 다시 만들어보면서 다시 정리해보는게 도움이 많이 된다.

​

3) 조건이 붙는 경우에는 이 조건이 리스트에서 한 차원을 쓰게 한다.

예를 들어 백준 1309 동물원 문제를 보면, 

'가로 두칸, 세로 n칸인 동물원에서 동물을 0~N마리중에서 배치할 수 있고, 이때 동물이 가로와 세로로 붙어있게 배치할 수 없다. 가능한 배치수는?' 이다. 

이 경우 '동물이 가로, 세로로 붙어있게 배치할 수 없음' 이라는 특별한 조건이 붙는다. 

이 경우,  예시를 만들면서 생각하는 것이 좋다. 세로로 1번째 칸을 채웠을 경우, 다음 칸에는 어떤 경우의 수가 올 수 있을까?를 생각해보고 다다음칸에도 이와 같은 옵션이 있는지 확인해보라. 만약 현재칸 다음의 칸에서도 같은 옵션이 가능하다면, 이를 가능한 케이스로 선정하여,

d[i][0], d[i][1],d[i][2]같은 리스트를 만들어 점화식을 만들면 된다. 

​

4) 이런 저런 삽질을 많이 하게 된다. 삽질하다가 갑자기 딱 보이는 경우가 많으니 삽질할까봐 두려워할 필요가 없음

​

5 가끔 부분수열 문제처럼 특정 전체 인덱스에서 몇개를 고르는 문제들이 있다. 이 경우 특정 인덱스 i 를 반드시 사용하여 만들 수 있는 경우의 수를 d[i] 로 놓고, 조건에 맞는 값을 d[0] ~ d[n] 중 찾게끔 설계하면 편하게 풀 수 있었다. 

이 때, d[i]는 d[0]~d[i-1]를 통해 구한다.

​

​

​

2. 관계를 세운 후

점화을 다 세우고 나서도 중요하다.

점화식이 돌아가려면 먼저 상수값이 존재하거나, n같은 크기조건에 따라서 점화식이 돌아가기 전에 완전히 정해지는 값들이 있어야된다.

​

나는 보통 예시를 만들면서 n에 대한 일반식같이 점화식과 무관한 식을 구하고, 점화식을 찾은 후에는 점화식의 범위를 결정하면서 반복문에 쓸 range를 구한다. 점화식에 range의 처음값을 대입해보면, 내가 미리 구해놔야하는 값들이 무엇인지 알기 쉽다.
[출처] 파이썬) dp문제푸는 팁|작성자 휘리릭
'''

'''
DP(Dynamic Programming), 동적 프로그래밍  : **하나의 문제는 단 한번만 풀도록 하는 알고리즘**

프로그래밍 대회 준비하는 사람에게는 절대 피할 수 없는 알고리즘이다. 자주 출제됨

다이나믹 프로그래밍은 다음의 가정 하에 사용할 수 있다.

1. 큰 문제를 작은 문제로 나눌 수 있따.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

크고 어려운 문제가 있다고 가정하면 그 문제를 잘게 나누어서 해결한 뒤에 처리하여 나중에 전체의 답을 구하는 것이다.

한번 구한 값은 배열에 저장하여 반환해주기만 하고 다시 계산할 필요 없게 만든다.

시간복잡도는 O(N)
'''